(defpackage #:lll
  (:use #:cl)
  (:export #:lll))


(in-package #:lll)


(defun lll (basis)
  (let* ((row-dim (gauss:row-dimension basis))
         (reduced-basis (aux:copy-array basis)) (k 1) mu norm r t-val)
    (destructuring-bind (_ mus norms) (gs:gram-schmidt basis)
      (aux:while (> row-dim k)
        (setq mu (aref mus k (1- k)))
        (when (> (abs mu) 1/2)
          (setq r (if (> mu 0)
                      (floor (+ 1/2 mu))
                      (- (floor (- 1/2 mu)))))
          (aux:change-row! reduced-basis
                           (ops:vec-dif (aux:array-slice reduced-basis k)
                                        (ops:scalar-mult r (aux:array-slice reduced-basis (1- k))))
                           k)
          (do ((j 0 (1+ j))) ((= (1- k) j) (setf (aref mus k (1- k)) (- (aref mus k (1- k)) r)))
            (setf (aref mus k j) (- (aref mus k j) (* r (aref mus (1- k) j))))))
        (if (< (aref norms k) (* (- 3/4 (* (aref mus k (1- k)) (aref mus k (1- k)))) (aref norms (1- k))))
            (progn
              (setq mu (aref mus k (1- k))
                    norm (+ (aref norms k) (* mu mu (aref norms (1- k)))))
              (setf (aref mus k (1- k)) (/ (* mu (aref norms (1- k))) norm)
                    (aref norms k) (/ (* (aref norms (1- k)) (aref norms k)) norm)
                    (aref norms (1- k)) norm)
              (aux:switch-rows! reduced-basis k (1- k))
              (when (> k 1)
                (do ((j 0 (1+ j))) ((= (1- k) j))
                  (psetf (aref mus k j) (aref mus (1- k) j)
                         (aref mus (1- k) j) (aref mus k j))))
              (do ((s (1+ k) (1+ s))) ((= row-dim s))
                (setq t-val (aref mus s k))
                (setf (aref mus s k) (- (aref mus s (1- k)) (* mu t-val))
                      (aref mus s (1- k)) (+ t-val (* (aref mus k (1- k)) (aref mus s k)))))
              (setq k (max 1 (1- k))))
            (progn
              (do ((l (- k 2) (1- l))) ((= -1 l))
                (setq mu (aref mus k l))
                (when (> (abs mu) 1/2)
                  (setq r (if (> mu 0)
                              (floor (+ 1/2 mu))
                              (- (floor (- 1/2 mu)))))
                  (aux:change-row! reduced-basis
                                   (ops:vec-dif (aux:array-slice reduced-basis k)
                                                (ops:scalar-mult r (aux:array-slice reduced-basis l)))
                                   k)
                  (do ((j 0 (1+ j))) ((= l j) (setf (aref mus k l) (- (aref mus k l) r)))
                    (setf (aref mus k j) (- (aref mus k j) (* r (aref mus l j)))))))
              (setq k (1+ k)))))) reduced-basis))
